import './index.css';
import React, { useState } from 'react';
import { ChevronLeft, ChevronRight, BookOpen, Check, X } from 'lucide-react';

const TOCFlashcards = () => {
  const [currentUnit, setCurrentUnit] = useState(0);
  const [currentCard, setCurrentCard] = useState(0);
  const [isFlipped, setIsFlipped] = useState(false);
  const [showMenu, setShowMenu] = useState(true);

  const units = [
    {
      title: "Unit 1: Finite Automata",
      cards: [
        {
          q: "What is a Deterministic Finite Automaton (DFA)?",
          a: "A DFA is a 5-tuple (Q, Σ, δ, q₀, F) where:\n• Q = finite set of states\n• Σ = input alphabet\n• δ: Q × Σ → Q (transition function)\n• q₀ ∈ Q (start state)\n• F ⊆ Q (accept states)\n\nKey: For each state and input symbol, there's exactly ONE next state."
        },
        {
          q: "What's the difference between DFA and NFA?",
          a: "DFA:\n• One transition per state-symbol pair\n• Deterministic (predictable path)\n• No ε-transitions\n\nNFA:\n• Multiple possible transitions\n• Non-deterministic (choices allowed)\n• Can have ε-transitions\n\nImportant: Every NFA can be converted to an equivalent DFA!"
        },
        {
          q: "What are ε-transitions in ε-NFA?",
          a: "ε-transitions allow moving between states WITHOUT consuming input.\n\nExample: State q₁ --ε--> q₂\n(Move from q₁ to q₂ without reading any symbol)\n\nUse case: Makes automata design simpler for complex patterns.\n\nNote: Any ε-NFA can be converted to NFA/DFA by computing ε-closure."
        },
        {
          q: "How to convert NFA to DFA? (Subset Construction)",
          a: "Algorithm:\n1. Start with ε-closure of NFA start state\n2. For each new DFA state (set of NFA states):\n   - For each input symbol a\n   - Find all NFA states reachable on 'a'\n   - Take ε-closure of result = new DFA state\n3. DFA accept states = any set containing NFA accept state\n\nKey insight: DFA states represent SETS of NFA states"
        },
        {
          q: "Applications of Finite Automata?",
          a: "1. Lexical Analysis:\n   - Tokenizing source code in compilers\n   - Identifying keywords, identifiers, operators\n\n2. Pattern Matching:\n   - Text search (grep, editors)\n   - Regular expression matching\n\n3. Protocol Design:\n   - Network protocols\n   - Communication systems\n\n4. Hardware Design:\n   - Digital circuit controllers"
        }
      ]
    },
    {
      title: "Unit 2: Regular & Non-Regular Languages",
      cards: [
        {
          q: "What is a Regular Language?",
          a: "A language L is regular if:\n• It can be accepted by a DFA/NFA, OR\n• It can be described by a Regular Expression, OR\n• It can be generated by a Regular Grammar\n\nExamples:\n• {w | w has even number of 0s}\n• {w | w ends with 01}\n• a*b* (all a's followed by all b's)"
        },
        {
          q: "What are Closure Properties of Regular Languages?",
          a: "If L₁ and L₂ are regular, then these are also regular:\n\n1. Union: L₁ ∪ L₂\n2. Intersection: L₁ ∩ L₂\n3. Concatenation: L₁L₂\n4. Kleene Star: L₁*\n5. Complement: Σ* - L₁\n6. Reversal: L₁ᴿ\n7. Difference: L₁ - L₂\n\nProof technique: Construct automata for result"
        },
        {
          q: "State the Pumping Lemma for Regular Languages",
          a: "For every regular language L, ∃ pumping length p such that:\n\nFor any string s ∈ L where |s| ≥ p:\ns can be split as s = xyz where:\n1. |xy| ≤ p\n2. |y| > 0\n3. ∀i ≥ 0, xyⁱz ∈ L\n\nUse: To PROVE a language is NOT regular\n(Show no valid split exists)"
        },
        {
          q: "How to use Pumping Lemma to prove non-regularity?",
          a: "Example: L = {0ⁿ1ⁿ | n ≥ 0} is not regular\n\nProof by contradiction:\n1. Assume L is regular with pumping length p\n2. Choose s = 0ᵖ1ᵖ (clearly in L, |s| ≥ p)\n3. By PL, s = xyz where |xy| ≤ p, |y| > 0\n4. Since |xy| ≤ p, y contains only 0's\n5. Pump: xy²z = 0ᵖ⁺|y|1ᵖ ∉ L\n6. Contradiction! L is not regular."
        },
        {
          q: "What is DFA Minimization?",
          a: "Process of creating smallest DFA for a language.\n\nAlgorithm (Table-Filling):\n1. Mark pairs (F, non-F) as distinguishable\n2. For unmarked pairs (p,q), check if:\n   δ(p,a) and δ(q,a) are distinguishable\n3. If yes, mark (p,q)\n4. Repeat until no new marks\n5. Merge all unmarked pairs\n\nResult: Minimal DFA with fewest states"
        },
        {
          q: "Examples of Non-Regular Languages",
          a: "Classic examples:\n\n1. {0ⁿ1ⁿ | n ≥ 0} - balanced parentheses\n2. {ww | w ∈ {0,1}*} - string repeated\n3. {0ⁿ² | n ≥ 0} - perfect squares\n4. {aⁿbⁿcⁿ | n ≥ 0} - three-way balance\n\nWhy? All require counting/memory beyond finite states.\n\nProof: Use Pumping Lemma"
        }
      ]
    },
    {
      title: "Unit 3: Context-Free Grammars",
      cards: [
        {
          q: "What is a Context-Free Grammar (CFG)?",
          a: "CFG is a 4-tuple G = (V, T, P, S) where:\n• V = finite set of variables (non-terminals)\n• T = finite set of terminals\n• P = production rules (V → (V∪T)*)\n• S ∈ V = start symbol\n\nExample: S → aSb | ε\nGenerates: {aⁿbⁿ | n ≥ 0}\n\nKey: Left side has SINGLE variable"
        },
        {
          q: "What is a Derivation and Parse Tree?",
          a: "Derivation: Sequence of rule applications\nS ⇒ aSb ⇒ aaSbb ⇒ aabb\n\nParse Tree: Graphical representation\n      S\n     /|\\\n    a S b\n     /|\\\n    a S b\n      |\n      ε\n\nLeftmost: Expand leftmost variable first\nRightmost: Expand rightmost variable first"
        },
        {
          q: "What is Ambiguity in CFG?",
          a: "A CFG is ambiguous if some string has:\n• Multiple leftmost derivations, OR\n• Multiple parse trees\n\nExample: E → E+E | E*E | a\nString 'a+a*a' has 2 parse trees!\n\nFix: Add precedence rules or rewrite grammar\nE → E+T | T\nT → T*F | F\nF → a"
        },
        {
          q: "How to eliminate ε-productions?",
          a: "Algorithm:\n1. Find nullable variables (derive ε)\n2. For each rule A → α:\n   - If α contains nullable B\n   - Add rules with/without B\n3. Remove all A → ε rules (except S → ε if ε ∈ L)\n\nExample:\nS → AB, A → aA | ε, B → b\nA is nullable.\nNew: S → AB | B\nA → aA | a"
        },
        {
          q: "How to eliminate Unit Productions?",
          a: "Unit production: A → B (single variable)\n\nAlgorithm:\n1. Find all pairs (A,B) where A ⇒* B\n2. For each such pair and rule B → α:\n   - If α is not a unit production\n   - Add rule A → α\n3. Remove all unit productions\n\nExample:\nS → A, A → B, B → 0|1\nResult: S → 0|1"
        },
        {
          q: "What is Chomsky Normal Form (CNF)?",
          a: "Every rule must be:\n• A → BC (two variables), OR\n• A → a (single terminal), OR\n• S → ε (only if ε in language)\n\nConversion steps:\n1. Eliminate ε-productions\n2. Eliminate unit productions\n3. Replace terminals in long rules\n4. Break rules longer than 2\n\nUse: Simplifies parsing algorithms (CYK)"
        },
        {
          q: "Application: CFG in Compiler Design?",
          a: "Syntax Analysis (Parsing):\n\n1. Define language grammar:\n   - Expressions: E → E+E | (E) | id\n   - Statements: S → if(E)S | while(E)S\n\n2. Build parse tree\n   - Verify syntax correctness\n   - Create AST for code generation\n\n3. Error detection:\n   - Mismatched parentheses\n   - Invalid syntax\n\nReal tools: Yacc, Bison use CFGs"
        }
      ]
    },
    {
      title: "Unit 4: Pushdown Automata",
      cards: [
        {
          q: "What is a Pushdown Automaton (PDA)?",
          a: "PDA = NFA + Stack\n\n7-tuple: (Q, Σ, Γ, δ, q₀, Z₀, F)\n• Q = states\n• Σ = input alphabet\n• Γ = stack alphabet\n• δ: Q × (Σ∪ε) × Γ → P(Q × Γ*)\n• q₀ = start state\n• Z₀ = initial stack symbol\n• F = accept states\n\nKey: Stack provides memory!"
        },
        {
          q: "PDA vs DFA: What's the difference?",
          a: "DFA:\n• Finite memory (states only)\n• Accepts regular languages\n• {0ⁿ1ⁿ} ✗ Cannot accept\n\nPDA:\n• Infinite memory (stack)\n• Accepts context-free languages\n• {0ⁿ1ⁿ} ✓ Can accept\n\nPDA can count using stack!\nPush on 0's, pop on 1's"
        },
        {
          q: "What are the two types of PDA acceptance?",
          a: "1. Acceptance by Final State:\n   - Input consumed AND\n   - End in state ∈ F\n   - Stack can have anything\n\n2. Acceptance by Empty Stack:\n   - Input consumed AND\n   - Stack becomes empty\n   - State doesn't matter\n\nTheorem: Both methods are equivalent!\n(Can convert between them)"
        },
        {
          q: "How does PDA accept {0ⁿ1ⁿ}?",
          a: "Algorithm:\n1. Start with Z₀ on stack\n2. For each 0:\n   - Push X onto stack\n3. For each 1:\n   - Pop X from stack\n4. Accept if:\n   - Input finished\n   - Stack has only Z₀\n\nTransitions:\nδ(q₀, 0, Z₀) = {(q₀, XZ₀)}\nδ(q₀, 0, X) = {(q₀, XX)}\nδ(q₀, 1, X) = {(q₁, ε)}\nδ(q₁, 1, X) = {(q₁, ε)}\nδ(q₁, ε, Z₀) = {(qf, Z₀)}"
        },
        {
          q: "DPDA vs NPDA: Key differences?",
          a: "DPDA (Deterministic):\n• At most ONE move per configuration\n• Cannot have both ε-move and symbol-move\n• More restricted power\n• Example: {0ⁿ1ⁿ}\n\nNPDA (Non-deterministic):\n• Multiple possible moves\n• Can guess choices\n• Full CFG power\n• Example: {wwᴿ | w ∈ {0,1}*}\n\nImportant: DPDA ⊂ NPDA ≡ CFG"
        },
        {
          q: "Theorem: PDA ≡ CFG",
          a: "Every CFG has equivalent PDA and vice versa.\n\nCFG → PDA:\n• One state design\n• Stack stores grammar symbols\n• Simulate leftmost derivation\n\nPDA → CFG:\n• Variables represent stack configs\n• Productions simulate PDA moves\n• Complex construction\n\nConclusion: PDA and CFG define same class (CFL)"
        },
        {
          q: "Applications of PDA?",
          a: "1. Parsing:\n   - Compiler syntax analysis\n   - Top-down/bottom-up parsers\n\n2. Balanced Parentheses:\n   - XML/HTML validation\n   - Expression checking\n\n3. Recursive Structures:\n   - Nested function calls\n   - Block structures in code\n\n4. Natural Language:\n   - Simple grammar parsing\n   - Sentence structure analysis"
        }
      ]
    },
    {
      title: "Unit 5: Turing Machines",
      cards: [
        {
          q: "What is a Turing Machine (TM)?",
          a: "Most powerful computational model!\n\n7-tuple: (Q, Σ, Γ, δ, q₀, B, F)\n• Q = finite states\n• Σ = input alphabet\n• Γ = tape alphabet (Σ ⊂ Γ)\n• δ: Q × Γ → Q × Γ × {L,R}\n• q₀ = start state\n• B = blank symbol\n• F = final states\n\nKey: Infinite tape, read/write head, can move L/R"
        },
        {
          q: "How does a Turing Machine work?",
          a: "Execution:\n1. Input on infinite tape\n2. Head starts at leftmost symbol\n3. Based on (state, symbol):\n   - Write new symbol\n   - Move head L or R\n   - Change state\n4. Repeat until:\n   - Reach final state (ACCEPT)\n   - No transition (REJECT)\n   - Loop forever (DOESN'T HALT)\n\nPower: Can compute anything computable!"
        },
        {
          q: "What are variants of Turing Machines?",
          a: "1. Multi-tape TM:\n   - Multiple independent tapes\n   - Parallel reading/writing\n   - More efficient, same power\n\n2. Non-deterministic TM:\n   - Multiple possible moves\n   - Accepts if ANY path accepts\n   - Same power as deterministic!\n\n3. Universal TM:\n   - Takes TM description as input\n   - Simulates that TM\n   - Like a programmable computer!\n\nTheorem: ALL variants equivalent in power"
        },
        {
          q: "What is the Halting Problem?",
          a: "Problem: Given TM M and input w, does M halt on w?\n\nTheorem: HALTING PROBLEM IS UNDECIDABLE!\n\nProof (by contradiction):\n1. Assume TM H decides halting\n2. Construct TM D:\n   - If H says \"M halts on M\", loop forever\n   - If H says \"M doesn't halt\", halt\n3. Run D on D:\n   - If D halts on D, then D loops (contradiction!)\n   - If D loops on D, then D halts (contradiction!)\n\nConclusion: Some problems are unsolvable!"
        },
        {
          q: "Recursive vs Recursively Enumerable Languages",
          a: "Recursive (Decidable):\n• TM always halts\n• Answers YES or NO\n• Examples: Regular, CFL\n• Can determine membership\n\nRecursively Enumerable:\n• TM may not halt on reject\n• If string in L, TM halts and accepts\n• If string not in L, TM may loop forever\n• Examples: All TM-acceptable languages\n\nRelation: Recursive ⊂ RE"
        },
        {
          q: "What is the Church-Turing Thesis?",
          a: "THESIS (not a theorem!):\n\"Any effectively computable function can be computed by a Turing Machine.\"\n\nMeaning:\n• TM captures ALL possible algorithms\n• No more powerful model exists\n• Computer = physical TM\n\nImplications:\n• Unsolvable problems exist\n• Computational limits are fundamental\n• Theory applies to real computers"
        },
        {
          q: "Decidability: Key Concepts",
          a: "Decidable Problems:\n• Regular language membership ✓\n• CFG emptiness ✓\n• DFA equivalence ✓\n\nUndecidable Problems:\n• Halting problem ✗\n• TM equivalence ✗\n• Post Correspondence Problem ✗\n• Does TM accept anything? ✗\n\nTechnique: Reduction\n(Show new problem at least as hard as known undecidable)"
        },
        {
          q: "Applications of Turing Machines?",
          a: "Theoretical:\n• Define computability\n• Prove unsolvability\n• Complexity theory foundation\n\nPractical insights:\n• Algorithm design limits\n• Compiler decidability\n• Software verification boundaries\n\nReal world:\n• Computer architecture models\n• Programming language theory\n• AI and logic reasoning"
        }
      ]
    }
  ];

  const currentUnitData = units[currentUnit];
  const currentCardData = currentUnitData.cards[currentCard];
  const totalCards = currentUnitData.cards.length;

  const nextCard = () => {
    if (currentCard < totalCards - 1) {
      setCurrentCard(currentCard + 1);
      setIsFlipped(false);
    }
  };

  const prevCard = () => {
    if (currentCard > 0) {
      setCurrentCard(currentCard - 1);
      setIsFlipped(false);
    }
  };

  const selectUnit = (unitIndex) => {
    setCurrentUnit(unitIndex);
    setCurrentCard(0);
    setIsFlipped(false);
    setShowMenu(false);
  };

  if (showMenu) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 p-8">
        <div className="max-w-4xl mx-auto">
          <div className="bg-white rounded-2xl shadow-xl p-8 mb-6">
            <h1 className="text-4xl font-bold text-center mb-2 bg-gradient-to-r from-purple-600 to-blue-600 bg-clip-text text-transparent">
              Theory of Computation
            </h1>
            <p className="text-center text-gray-600 mb-8">Interactive Study Flashcards</p>
          </div>

          <div className="grid gap-4">
            {units.map((unit, idx) => (
              <button
                key={idx}
                onClick={() => selectUnit(idx)}
                className="bg-white rounded-xl shadow-lg p-6 hover:shadow-xl transition-all transform hover:-translate-y-1 text-left"
              >
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <h2 className="text-xl font-bold text-gray-800 mb-2">{unit.title}</h2>
                    <p className="text-sm text-gray-600">{unit.cards.length} flashcards</p>
                  </div>
                  <BookOpen className="text-purple-600 w-8 h-8" />
                </div>
              </button>
            ))}
          </div>

          <div className="mt-8 bg-blue-50 border-l-4 border-blue-500 p-6 rounded-lg">
            <h3 className="font-bold text-blue-900 mb-2">Study Tips:</h3>
            <ul className="text-blue-800 text-sm space-y-1">
              <li>• Click on any card to flip and see the answer</li>
              <li>• Use arrow buttons to navigate through cards</li>
              <li>• Review each unit multiple times for better retention</li>
              <li>• Try to recall the answer before flipping the card</li>
            </ul>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-50 to-blue-50 p-4 sm:p-8">
      <div className="max-w-4xl mx-auto">
        {/* Header */}
        <div className="bg-white rounded-2xl shadow-xl p-4 sm:p-6 mb-6">
          <button
            onClick={() => setShowMenu(true)}
            className="text-purple-600 hover:text-purple-800 mb-4 flex items-center gap-2"
          >
            ← Back to Units
          </button>
          <h2 className="text-2xl sm:text-3xl font-bold text-gray-800 mb-2">
            {currentUnitData.title}
          </h2>
          <div className="flex items-center justify-between">
            <p className="text-gray-600">
              Card {currentCard + 1} of {totalCards}
            </p>
            <div className="w-48 bg-gray-200 rounded-full h-2">
              <div
                className="bg-gradient-to-r from-purple-600 to-blue-600 h-2 rounded-full transition-all"
                style={{ width: `${((currentCard + 1) / totalCards) * 100}%` }}
              />
            </div>
          </div>
        </div>

        {/* Flashcard */}
        <div
          className="relative h-96 cursor-pointer mb-6"
          onClick={() => setIsFlipped(!isFlipped)}
        >
          <div
            className={`absolute w-full h-full transition-all duration-500 transform-gpu ${
              isFlipped ? 'rotate-y-180' : ''
            }`}
            style={{
              transformStyle: 'preserve-3d',
              transform: isFlipped ? 'rotateY(180deg)' : 'rotateY(0deg)'
            }}
          >
            {/* Front */}
            <div
              className="absolute w-full h-full bg-gradient-to-br from-purple-500 to-blue-600 rounded-2xl shadow-2xl p-8 flex items-center justify-center"
              style={{ backfaceVisibility: 'hidden' }}
            >
              <div className="text-center">
                <div className="inline-block bg-white/20 px-4 py-2 rounded-full mb-4">
                  <span className="text-white font-semibold text-sm">QUESTION</span>
                </div>
                <p className="text-2xl sm:text-3xl font-bold text-white leading-relaxed">
                  {currentCardData.q}
                </p>
                <p className="text-white/80 mt-6 text-sm">Click to reveal answer</p>
              </div>
            </div>

            {/* Back */}
            <div
              className="absolute w-full h-full bg-white rounded-2xl shadow-2xl p-8 overflow-y-auto"
              style={{
                backfaceVisibility: 'hidden',
                transform: 'rotateY(180deg)'
              }}
            >
              <div className="inline-block bg-gradient-to-r from-green-500 to-emerald-600 px-4 py-2 rounded-full mb-4">
                <span className="text-white font-semibold text-sm">ANSWER</span>
              </div>
              <div className="text-gray-800 whitespace-pre-line leading-relaxed">
                {currentCardData.a}
              </div>
              <p className="text-gray-500 mt-6 text-sm text-center">Click to see question</p>
            </div>
          </div>
        </div>

        {/* Navigation */}
        <div className="flex justify-between items-center gap-4">
          <button
            onClick={prevCard}
            disabled={currentCard === 0}
            className={`flex items-center gap-2 px-6 py-3 rounded-xl font-semibold transition-all ${
              currentCard === 0
                ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                : 'bg-white text-purple-600 shadow-lg hover:shadow-xl hover:-translate-y-1'
            }`}
          >
            <ChevronLeft className="w-5 h-5" />
            Previous
          </button>

          <div className="flex gap-2">
            {Array.from({ length: totalCards }).map((_, idx) => (
              <button
                key={idx}
                onClick={() => {
                  setCurrentCard(idx);
                  setIsFlipped(false);
                }}
                className={`w-3 h-3 rounded-full transition-all ${
                  idx === currentCard
                    ? 'bg-purple-600 w-8'
                    : 'bg-gray-300 hover:bg-gray-400'
                }`}
              />
            ))}
          </div>

          <button
            onClick={nextCard}
            disabled={currentCard === totalCards - 1}
            className={`flex items-center gap-2 px-6 py-3 rounded-xl font-semibold transition-all ${
              currentCard === totalCards - 1
                ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                : 'bg-gradient-to-r from-purple-600 to-blue-600 text-white shadow-lg hover:shadow-xl hover:-translate-y-1'
            }`}
          >
            Next
            <ChevronRight className="w-5 h-5" />
          </button>
        </div>

        {/* Tips */}
        {currentCard === 0 && (
          <div className="mt-8 bg-yellow-50 border-l-4 border-yellow-500 p-4 rounded-lg">
            <p className="text-yellow-800 text-sm">
              <strong>Pro tip:</strong> Try to answer the question mentally before flipping the card. Active recall strengthens memory!
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

export default TOCFlashcards;